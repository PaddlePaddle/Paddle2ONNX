/* Copyright (c) 2016 PaddlePaddle Authors. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License. */

syntax = "proto2";
package paddle.standard_model.proto;

// Any incompatible changes to ProgramDesc and its dependencies should
// raise the version defined version.h.
//
// Serailization and Deserialization codes should be modified in a way
// that supports old versions following the version and compatibility policy.
message Version {
  optional int64 version = 1 [default = 0];
}

enum AttrType {
  INT = 0;
  FLOAT = 1;
  STRING = 2;
  INTS = 3;
  FLOATS = 4;
  STRINGS = 5;
  BOOLEAN = 6;
  BOOLEANS = 7;
  BLOCK = 8;
  LONG = 9;
  BLOCKS = 10;
  LONGS = 11;
  FLOAT64S = 12;
  VAR = 13;
  VARS = 14;
  FLOAT64 = 15;
}

// OperatorNode describes an instance of a C++ framework::OperatorBase
// derived class type.
message OperatorNode {
  message ListVariableType {
    repeated VariableType variable_type = 1;
  };

  required string operator_type = 3;
  map<string, ListVariableType> input = 1;
  map<string, ListVariableType> output = 2;
  map<string, Attribute> attribute = 4;
  optional bool is_target = 5 [default = false];
  required string name = 6;
  required string doc_string = 7;
  required string definition = 8;
};

// OpProto describes a C++ framework::OperatorBase derived class.
message OpProto {
  // VarProto describes the C++ type framework::Variable.
  message Var {
    required string name = 1;
    required string comment = 2;

    optional bool duplicable = 3 [default = false];
    optional bool intermediate = 4 [default = false];
    optional bool dispensable = 5 [default = false];
    optional bool extra = 6 [default = false];
    optional bool quant = 7 [default = false];
  }

  // AttrProto describes the C++ type Attribute.
  message Attr {
    required string name = 1;
    required AttrType type = 2;
    required string comment = 3;
    // If that attribute is generated, it means the Paddle third
    // language binding has responsibility to fill that
    // attribute. End-User should not set that attribute.
    optional bool generated = 4 [default = false];
    optional bool extra = 5 [default = false];
    optional bool quant = 6 [default = false];
    optional bool support_tensor = 7 [default = false];
  }

  required string type = 1;
  repeated Var inputs = 2;
  repeated Var outputs = 3;
  repeated Attr attrs = 4;
  required string comment = 5;
}

message VarType {
  enum Type {
    // Pod Types
    BOOL = 0;
    INT16 = 1;
    INT32 = 2;
    INT64 = 3;
    FP16 = 4;
    FP32 = 5;
    FP64 = 6;
    // phi::DenseTensor<size_t> is used in C++.
    SIZE_T = 19;
    UINT8 = 20;
    INT8 = 21;
    BF16 = 22;
    COMPLEX64 = 23;
    COMPLEX128 = 24;

    // Other types that may need additional descriptions
    LOD_TENSOR = 7;
    SELECTED_ROWS = 8;
    FEED_MINIBATCH = 9;
    FETCH_LIST = 10;
    STEP_SCOPES = 11;
    LOD_RANK_TABLE = 12;
    LOD_TENSOR_ARRAY = 13;
    PLACE_LIST = 14;
    READER = 15;
    // Any runtime decided variable type is raw
    // raw variables should manage their own allocations
    // in operators like nccl_op
    RAW = 17;
    TUPLE = 18;

    STRING = 25;
    STRINGS = 26;
    VOCAB = 27;
    FEED_LIST = 28;
    // The data type of phi::StringTensor
    PSTRING = 29;
    // the data type of phi::SparseCooTensor
    SPARSE_COO = 30;
    // the data type of phi::SparseCsrTensor
    SPARSE_CSR = 31;
  }

  required Type type = 1;

  message TensorDesc {
    // Should only be PODType. Is enforced in C++
    required Type data_type = 1;
    repeated int64 dims = 2;  // [UNK, 640, 480] is saved as [-1, 640, 480]
  }
  optional TensorDesc selected_rows = 2;

  message LoDTensorDesc {
    required TensorDesc tensor = 1;
    optional int32 lod_level = 2 [default = 0];
  }
  optional LoDTensorDesc lod_tensor = 3;

  message LoDTensorArrayDesc {
    required TensorDesc tensor = 1;
    optional int32 lod_level = 2 [default = 0];
  }
  optional LoDTensorArrayDesc tensor_array = 4;

  message ReaderDesc {
    repeated LoDTensorDesc lod_tensor = 1;
  }
  optional ReaderDesc reader = 5;

  message Tuple {
    repeated Type element_type = 1;
  }
  optional Tuple tuple = 7;

  optional TensorDesc string = 8;
  optional TensorDesc strings = 9;
  optional TensorDesc vocab = 10;
  optional TensorDesc sparse_coo = 11;
  optional TensorDesc sparse_csr = 12;
}

message VariableType {
  required string name = 1;
  required int64 data_type = 2;
  required Tensor tensor = 3;
  required bool is_persitable = 4;
  optional string doc_string = 5;
  optional AttrType type = 6;
};

message Dimension {
  required int64 size = 1;
  required string name = 2;
}

message TensorShape {
  required bool unknown = 1;
  repeated Dimension dim = 2;
}

message Tensor {
  required string name = 1;
  required TensorShape shape = 2;
  required int64 data_type = 3;
  repeated Type content = 4;
  optional int32 int32_data = 5;
  optional uint32 uint32_data = 6;
  optional int64 int64_data = 7;
  optional uint64 uint64_data = 8;
  optional float float_data = 9;
  optional double double_data = 10;
  optional bool bool_data = 11;
  optional string string_data = 12;
  required string format = 13;
}

message Type {
  optional int32 i = 2;
  optional float f = 3;
  optional string s = 4;
  optional bool b = 5;
  optional int64 l = 6;
  optional double float64 = 7;
}

message Attribute {
  required string name = 1;
  optional Type val = 2;
  repeated Type list = 3;
  required AttrType type = 4;
};

message Graph {
  required int32 id = 1;
  required int32 parent_idx = 2;
  repeated VariableType variable_type = 3;
  repeated OperatorNode operator_node = 4;
  optional int32 forward_block_idx = 5 [default = -1];
  optional VariableType input_nodes = 6;
  optional VariableType output_nodes = 7;
  repeated Graph sub_graphs = 8;
  map<string, Attribute> attribute = 9;
}

// In some cases, Paddle may perform operator definition iterations,
// and the operator uses OpVersionMap for compatibility testing.
message OpVersion {
  required int32 version = 1;
}
message OpVersionMap {
  message OpVersionPair {
    required string op_name = 1;
    required OpVersion op_version = 2;
  }
  repeated OpVersionPair pair = 1;
}

message ContributorsList {
  repeated string name = 1;
  repeated string email = 2;
  repeated string institute = 3;
}

// Please refer to
// https://github.com/PaddlePaddle/Paddle/blob/develop/doc/design/program.md
// for more details.
// TODO(panyx0718): A model can have multiple programs. Need a
// way to distinguish them. Maybe ID or name?
message Model {
  reserved 2, 3;  // For backward compatibility.
  repeated Graph graph = 1;
  required int64 version = 4;
  optional OpVersionMap op_version_map = 5;
  required ContributorsList contributors = 6;
  required string framework_name = 7;
  required string framework_version = 8;
  required string model_name = 9;
  required string model_version = 10;
  required string doc_url = 11;
  map<string, Attribute> attribute = 12;
}